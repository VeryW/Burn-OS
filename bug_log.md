| Type of bugs | The symptom | Rough Time of Finding the bug | The diffculty of fixing it |
| ---- | ---------------- | --------------- | ----------- |
| | | **MP3.1**  |
| Algorithmic error | After the paging initialization, the screen is interrupted by RTC only by once. It only shows a static screen without flickering. | 20 mins |  I thought I can reverse the 0 and 1 in a hexadecimal value by XOR it with itself at first.But I realized that it should be XORing with 0xffffffff instead to reverse 0 and 1. XORinga number with itself would clear every bits, which cause this problem. Just changing 2 lines can solve the problem.|  
| Algorithmic error | The kernel cannot boot, it always restart.  | 30 mins | I used to first call the enable_paging function and then call the load_page_directory. The order is wrong. We should first locate the page directory and then we can enable paging. Otherwise, the enable paging won't work at all. Just switch the load_page_directory and enable_paging function. | 
| Algorithmic error | The kernel cannot boot, it always restart. | 30 mins |I didn't set the PSE(page size extension), which leads to the problem that the 4MB size page cannot be used. So setting the PSE in CR0 can solve the problem|
| Algorithmic error |  The system failed to startup. Guess idt initialization may have wrong. | 15 mins | I wrongly thought that the reserved[1:4] field of idt entry have no need to be set. However, after reading through the document again, I find that they must be set to make the idt entry complete, or the incomplete idt initialization would crash the system. Modify 6 lines.|
| | | **MP3.2**  |
| Algorithmic error | It didn't read the correct file size, the size it showed is either 0 or a very large number. | 3 hours |  In the filesys_init function, I originally set the inode_ptr by `(inode_t*)(file_addr + 1)`. But since file_addr is of uin32_t* type, file_addr + 1 will point to next 32_bits instead of next inode block as indented. So I changed it to `(inode_t*)(boot_block_ptr + 1)`. Boot block has the same size as inode (4kB), therefore the pointer will point to the head of inode array properly now.|  
| Algorithmic error | The backspace can erase the former content on the screen.  | 30 mins | To sovle this problem, I use a little tricky method that I use the return value of `fill_buffer` to control whether we need to call `putc`. It solves two problems. One is that if the count of buffer is smaller than 0, backspace shouldn't put on the screen. The other one is that if it is overflow, the screen shouldn't display anymore. | 
| Algorithmic error | The backspace cannot erase the upper line information.  | 10 mins | I forgot to conside this situation. To sovle this problem, I add a consideration case in `putc`. Just 3-4 lines code added. | 
| | | **MP3.3**  |
| Algorithmic error | we cannot use keyboard to input command in the shell. | 1 hour |  In the idt.c, we wongly set the systerm call gate. We used to set it as the interrupt gate, the reserved3 is 0, which means the IF will be cleared so that the keyboard interrupt won't be responsed. Then, we set the reserved3 as 1 and solve the problem.|  
| Algorithmic error | while compiling, there are many multiple definitions for systemcall functions such as open, close and so on. | 2 days | we use a assembly file to store the system call linkage. At begin, the name of the assembly file is the same as the name of .C file. So both of them will be compiled into the same .O file. which will lead that in the .O file after compiled, there will be multiple definitions for system call functions. So changing the name of assembly file did solve the problem. | 
| Algorithmic error | while testing close, read, write functions, we found that there are Page-Faults | 1 hour | When we try to close, read, or open an invalid file, the given file descriptor of the pcb is in "available" status. Therefore, the functions are actually NULL here because we didn't initialize it. So when we try to dereference the functions, page-faults appear. Therefore, we need to determine whether the flag of the pcb's flag is 0 or not, if it is, return -1 because it is invalid. | 
| | | **MP3.4** |
| Algorithmic error | when calling getargs after first time, the content of buffer remains, with only the first letters replaced by new argument. | 10 mins | In function getargs, we incorrectly adjust nbytes to the length of the argument, causing the rest of the buffer remains. By removing such adjustification, the buffer is correctly cleaned up with only arguments read in.|
| | | **MP3.5**  |
| Algorithmic error | after booting, the kernel soon crashed out. | 20 mins | We open the three base shells in function scheduler(). However, the code to save ebp of scheduler context to pcb is later than the starting up base shell condition, which results in when scheduler returns to the first base shell for the first time and try to obtain the ebp of previous scheduler context, it dereferences a nullptr/sets ebp to 0. We move the ebp saving code ahead of starting up base shell condition to fix the bug.|  
| Algorithmic error | Can not type anything after terminal_switch (e.g. after press Alt+F2). | 30 mins | At first, we tried to open one terminal and execute "shell" on that terminal after each terminal_switch. However, we didn't have sti() in front of executing shell. As a result, the code enters "shell" codes and doesn't finish the keyboard_handler, therefore not "iret" and restore the IF properly. In that way, the IF will remain 0 after that, which accounts for no response of keyboard interrupts afterward. | 
| Algorithmic error | cannot execute cmd in the base shell of 2nd and 3rd terminal | 45 mins | There is a condition to judge whether send cmd in line buffer of keyboard to user buffer of shell in the func terminal_read(). We incorrectly set the condition to waiting "enter" input of foreground terminal. By changing it to waiting "enter" input of current executing terminal, we fixed the bug. |
| Algorithmic error | the input character would show in random terminal when typing. | 10 mins | We add a function putc_intr() to deal with putc of keyboard. However, we forgot to update video memory paging in this function, which means the video mapping in this function follows the one scheduler specified, resulting that the character should show in foreground terminal may show in the background. By adding updating video memory paging in the beginning and end of the function, the bug is fixed. |
| Algorithmic error | There is a small possibility that characters supposed to be printed on one terminal would be printed on another terminal during quick terminal switches. | 1 hour | The bug is in terminal_switch. Originally, we first used update_video_memory_paging(sche_term) to map the video_memory back to the original scheduler_terminal, then updated current_terminal to be target_terminal. However, this will cause the scheduler terminal will be compared to the original current terminal inside update_video_memory_paging instead of comparing with the new current terminal. If the scheduler terminal equals the original current terminal, the video memory paging would wrongly point to the physical video memory paging, then the characters will be printed on the screen. |
